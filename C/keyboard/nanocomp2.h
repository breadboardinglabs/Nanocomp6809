/***************************************************************************//**

  @file         nanocomp2.h

  @author       Dave Henry

  @date         Created Friday, 20 January 2023

  @brief        Nanocomp 6809 specific declarations.

  @copyright    Based on Tetris C source by Stephen Brennan.  Released under the Revised
                BSD License.  See LICENSE.txt for details.
  Now includes Keyboard scan code conversion logic
*******************************************************************************/
#include "cmoc.h"
#include "cmocextra.h"

#ifndef NANOCOMP_H
#define NANOCOMP_H

/*
  Nanocomp VGA controller colours
 */

#define COLOR_BLACK 0
#define COLOR_DARK_GREY 1
#define COLOR_BLUE 2
#define COLOR_LIGHT_BLUE 3
#define COLOR_GREEN 4
#define COLOR_LIGHT_GREEN 5
#define COLOR_DARK_CYAN 6
#define COLOR_CYAN 7
#define COLOR_RED 8
#define COLOR_ORANGE 9
#define COLOR_MAGENTA 10
#define COLOR_PINK 11
#define COLOR_DARK_YELLOW 12
#define COLOR_YELLOW 13
#define COLOR_GREY 14
#define COLOR_WHITE 15


/* Keyboard Controller Constants based on BIOS by Sergey Kiselev.
*/

// keyboard controller return codes
#define kbc_ret_test 0xAA // keyboard controller test passed
// keyboard controller status register and its bits
#define kbc_stat_obf 0x01	// output buffer full flag
#define kbc_stat_ibf 0x02 // input buffer full flag
#define kbc_stat_aobf 0x20	// auxiliary output buffer full flag
#define kbc_stat_tout	0x40 // receive/transmit timeout
#define kbc_stat_perr	0x80 // parity error

// keyboard contoller command register and commands
#define kbc_cmd_rd_ctr	0x20 // read controller configuration byte command
#define kbc_cmd_wr_ctr 0x60 // write controller configruation byte command

#define kbc_cmd_aux_dis 0xA7	// disable auxiliary interface command
#define kbc_cmd_aux_ena 0xA8	// enable auxiliary interface command
#define kbc_cmd_aux_tst 0xA9	// test auxiliary interface command
#define kbc_cmd_test 0xAA	// keyboard controller self-test command
#define kbc_cmd_kbd_tst 0xAB	// test keyboard interface command
#define kbc_cmd_kbd_dis 0xAD	// disable keyboard interface command
#define kbc_cmd_kbd_ena 0xAE	// enable keyboard interface command
#define kbc_cmd_rd_in 0xC0	// read keyboard input port
#define kbc_cmd_aux_snd 0xD4	// send command byte to auxiliary device command
// keyboard controller control register bits
#define kbc_ctr_kbd_int 0x01	// enable keyboard OBF interrupt
#define kbc_ctr_aux_int 0x02	// enable auxiliary OBF interrupt
#define kbc_ctr_no_lock 0x08	// ignore keyboard inhibit (keyboard lock)
#define kbc_ctr_kbd_dis	0x10	// disable keyboard interface
#define kbc_ctr_aux_dis 0x20	// disable auxiliary interface
#define kbc_ctr_xlat 0x40	// enable keyboard scancode translation

// keyboard and auxiliary device commands
#define dev_cmd_enable 0xF4	// device enable
#define dev_cmd_disable 0xF5	// device disable
#define dev_cmd_reset 0xFF	// reset and self-test
#define dev_cmd_echo 0xEE	// Echo test

// keyboard and auxiliary device responses
#define dev_rsp_bat_ok 0xAA	// basic assurance test is OK
#define dev_rsp_ack	0xFA	// acknowledge
#define dev_rsp_error	0xFC	// error (basic assurance test failed)
#define dev_rsp_resend 0xFE	// resend (invalid command or argument)
#define kbc_ctr_timeout 5000 // Was 500/ 20,000 in original 8088 BIOS
/*
  Nanocomp memory map constants
 */
 
#define RAM_START           0x0000
#define PIA_PORTA           0xD000
#define PIA_PORTB           0xD001
#define PIA_CTRLA           0xD002
#define PIA_CTRLB           0xD003
#define CRTC_ADDRESS        0xD400
#define PAGE_REGISTER       0xD480
#define KBD_DATA_REG       0xD600  // Read/Write D600-D67F   /Y3CRTC
#define KBD_STATUS_REG      0xD601  // Read D600-D67F   /Y3CRTC Note that PC uses A2 for A0 so would be D600 and D604
#define KBD_COMMAND_REG     0xD601  // Write D600-D67F   /Y3CRTC

#define CRTC_DATA_REGISTER  0xD401
#define CRTC_DAC_ADD_WR     0xD580
#define CRTC_DAC_COL_VALUE  0xD581
#define CRTC_DAC_PIXEL_MASK 0xD582
#define CRTC_DAC_ADD_RD     0xD583

#define VIDEO_RAM           0x8000 // Start of Video RAM
#define VIDEO_RAM_END       0xBFFF // End of Video RAM
#define CG_RAM              0xC000 // Start of character generator RAM
#define CG_RAM_END          0xCFFF // End of character generator RAM
#define CG_RAM_F0           0xCF00 // End of character generator RAM
#define CG_ROM              0xE000 // Start of character generator ROM
#define PALETTE_SIZE        256
//#define PALETTE_SIZE        2
#define PALETTE_COLOURS     3

extern const word VRAMOFFSET;
extern const word VRAMPAGE;
extern const word VRAMTOP;
extern const word VRAMPAGE3TOP;
 
//extern const word GMODE2;
extern const word PIXELSPERLINE;
extern const word BYTESPERROW;
extern const word BYTESPERCHARROW;

extern const word CHARSPERROW;
extern const word ROWSPERPAGE;
extern const byte LINEFEED;


extern const unsigned int CRTCAR;
extern const unsigned int CRTCDR;
extern const unsigned int COLOURLATCH;

extern byte *pageRegister;
extern int  page;
extern byte current_video_mode;
                                                             // Global VRAM page so don't have to keep updating
//unsigned int yLookup[59];                                               // This stores the pre-calculated addresses for each yrow
extern word yLookup[60];                                               // This stores the pre-calculated addresses for each yrow
extern byte pixelmaskLookup[8];

const byte VIDEO_MODE0 = 0x00;
const byte VIDEO_MODE1 = 0x04;
const byte VIDEO_MODE2 = 0x08;
const byte VIDEO_MODE3 = 0x0c;

/*
  Reserved Variables above stack for Video Controller
*/
#define DISP_ROW            0x7FC0 // Current Cursor Row 0-29
#define DISP_COL            0x7FC1 // Current Cursor Column 0-79
#define DISP_ROW_OFFSET     0x7FC2 // Starting byte of current row, will increment by 160 for each row
#define DISP_CLS            0x7FC4 // Clear screen word Colour Byte + Character $F320 White on Blue space
#define DISP_START_ADDRESS  0x7FC6 //Current CRTC Start Address value R12 High, R13 Low, scroll display buffer 
#define DISP_CURSOR_H       0x7FC8 //
#define DISP_CURSOR_L       0x7FC9 //
#define DISP_BYTES_PER_ROW  0xA0;  // 160 Bytes per row

/* Nanocomp 6809 Key Definitions for original keypad */
#define KEY_CN 0x25
#define KEY_G 0x35
#define KEY_I 0x32
#define KEY_L 0x05
#define KEY_M 0x31
#define KEY_P 0x15 /* P Punch replaced with S Save */
#define KEY_S 0x15
#define KEY_R 0x30

#define KEY_0 0x22
#define KEY_1 0x24
#define KEY_2 0x02
#define KEY_3 0x12
#define KEY_4 0x14
#define KEY_5 0x00
#define KEY_6 0x10
#define KEY_7 0x04
#define KEY_8 0x01
#define KEY_9 0x11
#define KEY_A 0x03
#define KEY_B 0x13
#define KEY_C 0x23
#define KEY_D 0x33
#define KEY_E 0x21
#define KEY_F 0x20


/* Nanocomp 6809 7 Segment Display Definitions */
#define SEG_0 0x7E
#define SEG_1 0x06
#define SEG_2 0x5B
#define SEG_3 0x1F
#define SEG_4 0x27
#define SEG_5 0x3D
#define SEG_6 0x7D
#define SEG_7 0x0E
#define SEG_8 0x7F
#define SEG_9 0x3F
#define SEG_A 0x6F
#define SEG_B 0x75
#define SEG_C 0x78
#define SEG_D 0x57
#define SEG_E 0x79
#define SEG_F 0x69
#define SEG_G 0x7C
#define SEG_M 0x6E /* (upside down U) */
#define SEG_P 0x6B
#define SEG_S 0x3D /* (Same as 5) */
#define SEG_U 0x76
#define SEG_X 0x67
#define SEG_Y 0x37
#define SEG_DASH 0x01
#define SEG_SPACE 0x00

// const definition means gets populated from assembley FCB rather than ldb # stb > saves a lot of bytes
const byte VGAPalette[PALETTE_SIZE][PALETTE_COLOURS] = {
  {0x00, 0x00, 0x00},
  {0x1f, 0x1f, 0x1f},
  {0x00, 0x00, 0x2a},
  {0x00, 0x00, 0x3f},
  {0x00, 0x2a, 0x00},
  {0x00, 0x3f, 0x00},
  {0x00, 0x2a, 0x2a},
  {0x00, 0x3f, 0x3f},
  {0x2a, 0x00, 0x00},
  {0x3f, 0x00, 0x00},
  {0x2a, 0x00, 0x2a},
  {0x3f, 0x00, 0x3f},
  {0x2a, 0x2a, 0x00},
  {0x3f, 0x3f, 0x00},
  {0x2a, 0x2a, 0x2a},
  {0x3f, 0x3f, 0x3f},
  {0x00, 0x00, 0x00},
  {0x05, 0x05, 0x05},
  {0x08, 0x08, 0x08},
  {0x0B, 0x0B, 0x0B},
  {0x0E, 0x0E, 0x0E},
  {0x11, 0x11, 0x11},
  {0x14, 0x14, 0x14},
  {0x18, 0x18, 0x18},
  {0x1C, 0x1C, 0x1C},
  {0x20, 0x20, 0x20},
  {0x24, 0x24, 0x24},
  {0x28, 0x28, 0x28},
  {0x2D, 0x2D, 0x2D},
  {0x32, 0x32, 0x32},
  {0x38, 0x38, 0x38},
  {0x3F, 0x3F, 0x3F},
  {0x00, 0x00, 0x3F},
  {0x10, 0x00, 0x3F},
  {0x1F, 0x00, 0x3F},
  {0x2F, 0x00, 0x3F},
  {0x3F, 0x00, 0x3F},
  {0x3F, 0x00, 0x2F},
  {0x3F, 0x00, 0x1F},
  {0x3F, 0x00, 0x10},
  {0x3F, 0x00, 0x00},
  {0x3F, 0x10, 0x00},
  {0x3F, 0x1F, 0x00},
  {0x3F, 0x2F, 0x00},
  {0x3F, 0x3F, 0x00},
  {0x2F, 0x3F, 0x00},
  {0x1F, 0x3F, 0x00},
  {0x10, 0x3F, 0x00},
  {0x00, 0x3F, 0x00},
  {0x00, 0x3F, 0x10},
  {0x00, 0x3F, 0x1F},
  {0x00, 0x3F, 0x2F},
  {0x00, 0x3F, 0x3F},
  {0x00, 0x2F, 0x3F},
  {0x00, 0x1F, 0x3F},
  {0x00, 0x10, 0x3F},
  {0x1F, 0x1F, 0x3F},
  {0x27, 0x1F, 0x3F},
  {0x2F, 0x1F, 0x3F},
  {0x37, 0x1F, 0x3F},
  {0x3F, 0x1F, 0x3F},
  {0x3F, 0x1F, 0x37},
  {0x3F, 0x1F, 0x2F},
  {0x3F, 0x1F, 0x27},
  {0x3F, 0x1F, 0x1F},
  {0x3F, 0x27, 0x1F},
  {0x3F, 0x2F, 0x1F},
  {0x3F, 0x37, 0x1F},
  {0x3F, 0x3F, 0x1F},
  {0x37, 0x3F, 0x1F},
  {0x2F, 0x3F, 0x1F},
  {0x27, 0x3F, 0x1F},
  {0x1F, 0x3F, 0x1F},
  {0x1F, 0x3F, 0x27},
  {0x1F, 0x3F, 0x2F},
  {0x1F, 0x3F, 0x37},
  {0x1F, 0x3F, 0x3F},
  {0x1F, 0x37, 0x3F},
  {0x1F, 0x2F, 0x3F},
  {0x1F, 0x27, 0x3F},
  {0x2D, 0x2D, 0x3F},
  {0x31, 0x2D, 0x3F},
  {0x36, 0x2D, 0x3F},
  {0x3A, 0x2D, 0x3F},
  {0x3F, 0x2D, 0x3F},
  {0x3F, 0x2D, 0x3A},
  {0x3F, 0x2D, 0x36},
  {0x3F, 0x2D, 0x31},
  {0x3F, 0x2D, 0x2D},
  {0x3F, 0x31, 0x2D},
  {0x3F, 0x36, 0x2D},
  {0x3F, 0x3A, 0x2D},
  {0x3F, 0x3F, 0x2D},
  {0x3A, 0x3F, 0x2D},
  {0x36, 0x3F, 0x2D},
  {0x31, 0x3F, 0x2D},
  {0x2D, 0x3F, 0x2D},
  {0x2D, 0x3F, 0x31},
  {0x2D, 0x3F, 0x36},
  {0x2D, 0x3F, 0x3A},
  {0x2D, 0x3F, 0x3F},
  {0x2D, 0x3A, 0x3F},
  {0x2D, 0x36, 0x3F},
  {0x2D, 0x31, 0x3F},
  {0x00, 0x00, 0x1C},
  {0x07, 0x00, 0x1C},
  {0x0E, 0x00, 0x1C},
  {0x15, 0x00, 0x1C},
  {0x1C, 0x00, 0x1C},
  {0x1C, 0x00, 0x15},
  {0x1C, 0x00, 0x0E},
  {0x1C, 0x00, 0x07},
  {0x1C, 0x00, 0x00},
  {0x1C, 0x07, 0x00},
  {0x1C, 0x0E, 0x00},
  {0x1C, 0x15, 0x00},
  {0x1C, 0x1C, 0x00},
  {0x15, 0x1C, 0x00},
  {0x0E, 0x1C, 0x00},
  {0x07, 0x1C, 0x00},
  {0x00, 0x1C, 0x00},
  {0x00, 0x1C, 0x07},
  {0x00, 0x1C, 0x0E},
  {0x00, 0x1C, 0x15},
  {0x00, 0x1C, 0x1C},
  {0x00, 0x15, 0x1C},
  {0x00, 0x0E, 0x1C},
  {0x00, 0x07, 0x1C},
  {0x0E, 0x0E, 0x1C},
  {0x11, 0x0E, 0x1C},
  {0x15, 0x0E, 0x1C},
  {0x18, 0x0E, 0x1C},
  {0x1C, 0x0E, 0x1C},
  {0x1C, 0x0E, 0x18},
  {0x1C, 0x0E, 0x15},
  {0x1C, 0x0E, 0x11},
  {0x1C, 0x0E, 0x0E},
  {0x1C, 0x11, 0x0E},
  {0x1C, 0x15, 0x0E},
  {0x1C, 0x18, 0x0E},
  {0x1C, 0x1C, 0x0E},
  {0x18, 0x1C, 0x0E},
  {0x15, 0x1C, 0x0E},
  {0x11, 0x1C, 0x0E},
  {0x0E, 0x1C, 0x0E},
  {0x0E, 0x1C, 0x11},
  {0x0E, 0x1C, 0x15},
  {0x0E, 0x1C, 0x18},
  {0x0E, 0x1C, 0x1C},
  {0x0E, 0x18, 0x1C},
  {0x0E, 0x15, 0x1C},
  {0x0E, 0x11, 0x1C},
  {0x14, 0x14, 0x1C},
  {0x16, 0x14, 0x1C},
  {0x18, 0x14, 0x1C},
  {0x1A, 0x14, 0x1C},
  {0x1C, 0x14, 0x1C},
  {0x1C, 0x14, 0x1A},
  {0x1C, 0x14, 0x18},
  {0x1C, 0x14, 0x16},
  {0x1C, 0x14, 0x14},
  {0x1C, 0x16, 0x14},
  {0x1C, 0x18, 0x14},
  {0x1C, 0x1A, 0x14},
  {0x1C, 0x1C, 0x14},
  {0x1A, 0x1C, 0x14},
  {0x18, 0x1C, 0x14},
  {0x16, 0x1C, 0x14},
  {0x14, 0x1C, 0x14},
  {0x14, 0x1C, 0x16},
  {0x14, 0x1C, 0x18},
  {0x14, 0x1C, 0x1A},
  {0x14, 0x1C, 0x1C},
  {0x14, 0x1A, 0x1C},
  {0x14, 0x18, 0x1C},
  {0x14, 0x16, 0x1C},
  {0x00, 0x00, 0x10},
  {0x04, 0x00, 0x10},
  {0x08, 0x00, 0x10},
  {0x0C, 0x00, 0x10},
  {0x10, 0x00, 0x10},
  {0x10, 0x00, 0x0C},
  {0x10, 0x00, 0x08},
  {0x10, 0x00, 0x04},
  {0x10, 0x00, 0x00},
  {0x10, 0x04, 0x00},
  {0x10, 0x08, 0x00},
  {0x10, 0x0C, 0x00},
  {0x10, 0x10, 0x00},
  {0x0C, 0x10, 0x00},
  {0x08, 0x10, 0x00},
  {0x04, 0x10, 0x00},
  {0x00, 0x10, 0x00},
  {0x00, 0x10, 0x04},
  {0x00, 0x10, 0x08},
  {0x00, 0x10, 0x0C},
  {0x00, 0x10, 0x10},
  {0x00, 0x0C, 0x10},
  {0x00, 0x08, 0x10},
  {0x00, 0x04, 0x10},
  {0x08, 0x08, 0x10},
  {0x0A, 0x08, 0x10},
  {0x0C, 0x08, 0x10},
  {0x0E, 0x08, 0x10},
  {0x10, 0x08, 0x10},
  {0x10, 0x08, 0x0E},
  {0x10, 0x08, 0x0C},
  {0x10, 0x08, 0x0A},
  {0x10, 0x08, 0x08},
  {0x10, 0x0A, 0x08},
  {0x10, 0x0C, 0x08},
  {0x10, 0x0E, 0x08},
  {0x10, 0x10, 0x08},
  {0x0E, 0x10, 0x08},
  {0x0C, 0x10, 0x08},
  {0x0A, 0x10, 0x08},
  {0x08, 0x10, 0x08},
  {0x08, 0x10, 0x0A},
  {0x08, 0x10, 0x0C},
  {0x08, 0x10, 0x0E},
  {0x08, 0x10, 0x10},
  {0x08, 0x0E, 0x10},
  {0x0B, 0x0B, 0x10},
  {0x08, 0x0C, 0x10},
  {0x08, 0x0A, 0x10},
  {0x0C, 0x0B, 0x10},
  {0x0D, 0x0B, 0x10},
  {0x0F, 0x0B, 0x10},
  {0x10, 0x0B, 0x10},
  {0x10, 0x0B, 0x0F},
  {0x10, 0x0B, 0x0D},
  {0x10, 0x0B, 0x0C},
  {0x10, 0x0B, 0x0B},
  {0x10, 0x0C, 0x0B},
  {0x10, 0x0D, 0x0B},
  {0x10, 0x0F, 0x0B},
  {0x10, 0x10, 0x0B},
  {0x0F, 0x10, 0x0B},
  {0x0D, 0x10, 0x0B},
  {0x0C, 0x10, 0x0B},
  {0x0B, 0x10, 0x0B},
  {0x0B, 0x10, 0x0C},
  {0x0B, 0x10, 0x0D},
  {0x0B, 0x10, 0x0F},
  {0x0B, 0x10, 0x10},
  {0x0B, 0x0F, 0x10},
  {0x0B, 0x0D, 0x10},
  {0x0B, 0x0C, 0x10},
  {0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00},
  {0x3F, 0x3F, 0x3F},
  {0x3F, 0x3F, 0x3F}
};


/*  Sin  Cos
0	    0	1000
18	309	 951
36	588	 809
54	809	 588
72	951	 309
90 1000	   0 */
//  0=-90, 5=0, 11=90 -90, -72, -54, -36, -18, 0, 18, 36, 54, 72, 90 
extern int sin[11];
extern int cos[11];
//=========================================================================
// scan_xlat_table - Keyboard scan code to ASCII and
//                   BIOS scan code translation table
// Note 1: Table starts with scancode == 1
// Note 2: The high byte of the 'Normal' field indicates key flags
//	00 - no flags
//	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
//	     x in this case equals digit value
//	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
//	40 - there is an extended key, so check for 0E0h flag
//	8x - F11, F12 BIOS scan codes
//	     (observation: for all other keys BIOS scan code == kbd scan code)
//-------------------------------------------------------------------------
// Based on x86 assembley by Sergey Kiselev.
// Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.

const word scan_xlat_table[88][4] = {
// Normal	Shift	Ctrl	Alt	Key	KeyShift	Scan
{0x001B, 0x011B, 0x011B, 0x01F0}, // Esc 01h
{0x0031, 0x0221, 0x0000, 0x7800}, // 1	! 02h
{0x0032, 0x0340, 0x0300, 0x7900}, // 2 @ 03h
{0x0033, 0x0423, 0x0000, 0x7A00}, // 3	#	04h
{0x0034, 0x0524, 0x0000, 0x7B00}, // 4	$	05h
{0x0035, 0x0625, 0x0000, 0x7C00}, // 5	%	06h
{0x0036, 0x075E, 0x071E, 0x7D00}, // 6 ^ 07h
{0x0037, 0x0826, 0x0000, 0x7E00}, // 7	&	08h
{0x0038, 0x092A, 0x0000, 0x7F00}, // 8	*	09h
{0x0039, 0x0A28, 0x0000, 0x8000}, // 9	(	0Ah
{0x0030, 0x0B29, 0x0000, 0x8100}, // 0	)	0Bh
{0x002D, 0x0C5F, 0x0C1F, 0x8200}, // - _ 0Ch
{0x003D, 0x0D2B, 0x0000, 0x8300}, // =	+	0Dh
{0x0008, 0x0E08, 0x0E7F, 0x0EF0}, // Back Space 0Eh
{0x0009, 0x0F00, 0x9400, 0xA500}, // Tab 0Fh
{0x2071, 0x1051, 0x1011, 0x1000}, // q	Q	10h
{0x2077, 0x1157, 0x1117, 0x1100}, // w	W	11h
{0x2065, 0x1245, 0x1205, 0x1200}, // e	E	12h
{0x2072, 0x1352, 0x1312, 0x1300}, // r	R	13h
{0x2074, 0x1454, 0x1414, 0x1400}, // t	T	14h
{0x2079, 0x1559, 0x1519, 0x1500}, // y	Y	15h
{0x2075, 0x1655, 0x1615, 0x1600}, // u	U	16h
{0x2069, 0x1749, 0x1709, 0x1700}, // i	I	17h
{0x206F, 0x184F, 0x180F, 0x1800}, // o	O	18h
{0x2070, 0x1950, 0x1910, 0x1900}, // p	P	19h
{0x005B, 0x1A7B, 0x1A1B, 0x1AF0}, // [	{	1Ah
{0x005D, 0x1B7D, 0x1B1D, 0x1BF0}, // ]	}	1Bh
{0x400D, 0x1C0D, 0x1C0A, 0x1CF0}, // Enter 1Ch
{0x0000, 0x0000, 0x0000, 0x0000},	// Ctrl	1Dh
{0x2061, 0x1E41, 0x1E01, 0x1E00}, // a	A	1Eh
{0x2073, 0x1F53, 0x1F13, 0x1F00}, // s	S	1Fh
{0x2064, 0x2044, 0x2004, 0x2000}, // d	D	20h
{0x2066, 0x2146, 0x2106, 0x2100}, // f	F	21h
{0x2067, 0x2247, 0x2207, 0x2200}, // g	G	22h
{0x2068, 0x2348, 0x2308, 0x2300}, // h	H	23h
{0x206A, 0x244A, 0x240A, 0x2400}, // j	J	24h
{0x206B, 0x254B, 0x250B, 0x2500}, // k	K	25h
{0x206C, 0x264C, 0x260C, 0x2600}, // l	L	26h
{0x003B, 0x273A, 0x0000, 0x27F0}, // ;	:	27h
{0x0027, 0x2822, 0x0000, 0x28F0}, // '	"	28h
{0x0060, 0x297E, 0x0000, 0x29F0}, // `	~	29h
{0x0000, 0x0000, 0x0000, 0x0000}, // Left Shift 2Ah
{0x005C, 0x2B7C, 0x2B1C, 0x2BF0}, // \	|	2Bh
{0x207A, 0x2C5A, 0x2C1A, 0x2C00}, // z	Z	2Ch
{0x2078, 0x2D58, 0x2D18, 0x2D00}, // x	X	2Dh
{0x2063, 0x2E43, 0x2E03, 0x2E00}, // c	C	2Eh
{0x2076, 0x2F56, 0x2F16, 0x2F00}, // v	V	2Fh
{0x2062, 0x3042, 0x3002, 0x3000}, // b	B	30h
{0x206E, 0x314E, 0x310E, 0x3100}, // n	N	31h
{0x206D, 0x324D, 0x320D, 0x3200}, // m	M	32h
{0x002C, 0x333C, 0x0000, 0x33F0}, // ,	<	33h
{0x002E, 0x343E, 0x0000, 0x34F0}, // .	>	34h
{0x602F, 0x353F, 0x0000, 0x35F0}, // /	?	35h
{0x0000, 0x0000, 0x0000, 0x0000},	// Right Shift 36h
{0x602A, 0x0000, 0x9600, 0x37F0}, // *	PrtSc	37h
{0x0000, 0x0000, 0x0000, 0x0000},	// Alt 38h
{0x0020, 0x3920, 0x3920, 0x3920}, // Space 39h
{0x0000, 0x0000, 0x0000, 0x0000},	// Caps Lock 3Ah
{0x0000, 0x5400, 0x5E00, 0x6800}, // F1 3Bh
{0x0000, 0x5500, 0x5F00, 0x6900}, // F2	3Ch
{0x0000, 0x5600, 0x6000, 0x6A00}, // F3	3Dh
{0x0000, 0x5700, 0x6100, 0x6B00}, // F4	3Eh
{0x0000, 0x5800, 0x6200, 0x6C00}, // F5	3Fh
{0x0000, 0x5900, 0x6300, 0x6D00}, // F6	40h
{0x0000, 0x5A00, 0x6400, 0x6E00}, // F7	41h
{0x0000, 0x5B00, 0x6500, 0x6F00}, // F8	42h
{0x0000, 0x5C00, 0x6600, 0x7000}, // F9	43h
{0x0000, 0x5D00, 0x6700, 0x7100}, // F1044h
{0x0000, 0x0000, 0x0000, 0x0000}, // Num Lock 45h
{0x0000, 0x0000, 0x0000, 0x0000},	// Scroll Lock 46h
{0x7700, 0x4737, 0x7700, 0x9700}, // Home	7	47h
{0x7800, 0x4838, 0x8D00, 0x9800}, // Up 	8	48h
{0x7900, 0x4939, 0x8400, 0x9900}, // PgUp	9	49h
{0x002D, 0x4A2D, 0x8E00, 0x4AF0}, // Gray - 4Ah
{0x7400, 0x4B34, 0x7300, 0x9B00}, // Left	4	4Bh
{0x75F0, 0x4C35, 0x8F00, 0x4CF0}, // Center 5 4Ch
{0x7600, 0x4D36, 0x7400, 0x9D00}, // Right 6	4Dh
{0x002B, 0x4E2B, 0x9000, 0x4EF0}, // Gray +	4Eh
{0x7100, 0x4F31, 0x7500, 0x9F00}, // End	1	4Fh
{0x7200, 0x5032, 0x9100, 0xA000}, // Down 2	50h
{0x7300, 0x5133, 0x7600, 0xA100}, // PgDn 3	51h
{0x7000, 0x5230, 0x9200, 0xA200}, // Ins	0	52h
{0x6000, 0x532E, 0x9300, 0xA300}, // Del	.	53h
{0x0000, 0x0000, 0x0000, 0x0000}, // SysRq 54h
{0x0000, 0x0000, 0x0000, 0x0000},	// NoKey 55h
{0x0000, 0x0000, 0x0000, 0x0000}, // NoKey 56h
{0x8500, 0x8700, 0x8900, 0x8B00}, // F11 57h
{0x8600, 0x8800, 0x8A00, 0x8C00}  // F12 58h
};
 

long roundl(long x);
word rawAddressToPaged (word address);
void ClearScreenGraphics();
void CRTCInit(int video_mode);
void plotPoint(int x, int y, byte colour);
void DrawLine(int x0, int y0, int x1, int y1, byte colour);
void DrawCircle(int xc,int yc,int r, byte colour);
void DrawFill(int x0, int y0, int x1, int y1, byte colour);
int clamp(int value, int min, int max);

byte HexToAscii(byte inputByte);
void Delay(int w);
void ClearScreen();
void PrintChr(byte ch);
void PrintColChr(byte colour, byte ch);
void newOutputRoutine();
void serialOutputRoutine();
byte GetKey();
byte PollChr(int wait);
void ncMove (int ncRow, int ncCol);
void returnNC();
void WaitForScreenBlank();
void WaitForScreenBlankInit();
void CopyCharGenRAM();
void DisableCursor();
void AddBlock (byte colour);
void ClearBlock ();
void DrawChar (int x, int y, byte character);
void DrawMessage(int x, int y, char * msg);
void ClearMessage(int x, int y, char * msg);
void PaletteInit();
void PaletteTest();

int keyboardInit();
int keyboardFlush();
int kbc_send_cmd(byte kbdCommand, byte kbdArgument);
int kbc_write_command(byte kbdCommand);
int kbc_write_data(byte kbdData);
int kbc_wait_write();
int kbc_read_data(byte *kbdStatus, byte *kbdData);
word get_kbd_char();

#endif // NANOCOMP_H
